{"ast":null,"code":"\"use strict\";\n\n// Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar hmac_1 = require(\"@stablelib/hmac\");\nvar wipe_1 = require(\"@stablelib/wipe\");\n/**\n * HMAC-based Extract-and-Expand Key Derivation Function.\n *\n * Implements HKDF from RFC5869.\n *\n * Expands the given master key with salt and info into\n * a limited stream of key material.\n */\nvar HKDF = /** @class */function () {\n  /**\n   * Create a new HKDF instance for the given hash function\n   * with the master key, optional salt, and info.\n   *\n   * - Master key is a high-entropy secret key (not a password).\n   * - Salt is a non-secret random value.\n   * - Info is application- and/or context-specific information.\n   */\n  function HKDF(hash, key, salt, info) {\n    if (salt === void 0) {\n      salt = new Uint8Array(0);\n    }\n    this._counter = new Uint8Array(1); // starts with zero\n    this._hash = hash;\n    this._info = info;\n    // HKDF-Extract uses salt as HMAC key, and key as data.\n    var okm = hmac_1.hmac(this._hash, salt, key);\n    // Initialize HMAC for expanding with extracted key.\n    this._hmac = new hmac_1.HMAC(hash, okm);\n    // Allocate buffer.\n    this._buffer = new Uint8Array(this._hmac.digestLength);\n    this._bufpos = this._buffer.length;\n  }\n  // Fill buffer with new block of HKDF-Extract output.\n  HKDF.prototype._fillBuffer = function () {\n    // Increment counter.\n    this._counter[0]++;\n    var ctr = this._counter[0];\n    // Check if counter overflowed.\n    if (ctr === 0) {\n      throw new Error(\"hkdf: cannot expand more\");\n    }\n    // Prepare HMAC instance for new data with old key.\n    this._hmac.reset();\n    // Hash in previous output if it was generated\n    // (i.e. counter is greater than 1).\n    if (ctr > 1) {\n      this._hmac.update(this._buffer);\n    }\n    // Hash in info if it exists.\n    if (this._info) {\n      this._hmac.update(this._info);\n    }\n    // Hash in the counter.\n    this._hmac.update(this._counter);\n    // Output result to buffer and clean HMAC instance.\n    this._hmac.finish(this._buffer);\n    // Reset buffer position.\n    this._bufpos = 0;\n  };\n  /**\n   * Expand returns next key material of the given length.\n   *\n   * It throws if expansion limit is reached (which is\n   * 254 digests of the underlying HMAC function).\n   */\n  HKDF.prototype.expand = function (length) {\n    var out = new Uint8Array(length);\n    for (var i = 0; i < out.length; i++) {\n      if (this._bufpos === this._buffer.length) {\n        this._fillBuffer();\n      }\n      out[i] = this._buffer[this._bufpos++];\n    }\n    return out;\n  };\n  HKDF.prototype.clean = function () {\n    this._hmac.clean();\n    wipe_1.wipe(this._buffer);\n    wipe_1.wipe(this._counter);\n    this._bufpos = 0;\n  };\n  return HKDF;\n}();\nexports.HKDF = HKDF;\n// TODO(dchest): maybe implement deriveKey?","map":{"version":3,"mappings":";;AAAA;AACA;;;;AAOA;AACA;AAEA;;;;;;;;AAQA;EAQI;;;;;;;;EAQA,cAAYA,IAAoB,EAC5BC,GAAe,EACfC,IAAwB,EACxBC,IAAiB;IADjB;MAAAD,WAAWE,UAAU,CAAC,CAAC,CAAC;IAAA;IAdpB,aAAQ,GAAG,IAAIA,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC;IAiBlC,IAAI,CAACC,KAAK,GAAGL,IAAI;IACjB,IAAI,CAACM,KAAK,GAAGH,IAAI;IAEjB;IACA,IAAMI,GAAG,GAAGC,WAAI,CAAC,IAAI,CAACH,KAAK,EAAEH,IAAI,EAAED,GAAG,CAAC;IAEvC;IACA,IAAI,CAACQ,KAAK,GAAG,IAAID,WAAI,CAACR,IAAI,EAAEO,GAAG,CAAC;IAEhC;IACA,IAAI,CAACG,OAAO,GAAG,IAAIN,UAAU,CAAC,IAAI,CAACK,KAAK,CAACE,YAAY,CAAC;IACtD,IAAI,CAACC,OAAO,GAAG,IAAI,CAACF,OAAO,CAACG,MAAM;EACtC;EAEA;EACQC,0BAAW,GAAnB;IACI;IACA,IAAI,CAACC,QAAQ,CAAC,CAAC,CAAC,EAAE;IAElB,IAAMC,GAAG,GAAG,IAAI,CAACD,QAAQ,CAAC,CAAC,CAAC;IAE5B;IACA,IAAIC,GAAG,KAAK,CAAC,EAAE;MACX,MAAM,IAAIC,KAAK,CAAC,0BAA0B,CAAC;;IAG/C;IACA,IAAI,CAACR,KAAK,CAACS,KAAK,EAAE;IAElB;IACA;IACA,IAAIF,GAAG,GAAG,CAAC,EAAE;MACT,IAAI,CAACP,KAAK,CAACU,MAAM,CAAC,IAAI,CAACT,OAAO,CAAC;;IAGnC;IACA,IAAI,IAAI,CAACJ,KAAK,EAAE;MACZ,IAAI,CAACG,KAAK,CAACU,MAAM,CAAC,IAAI,CAACb,KAAK,CAAC;;IAGjC;IACA,IAAI,CAACG,KAAK,CAACU,MAAM,CAAC,IAAI,CAACJ,QAAQ,CAAC;IAEhC;IACA,IAAI,CAACN,KAAK,CAACW,MAAM,CAAC,IAAI,CAACV,OAAO,CAAC;IAE/B;IACA,IAAI,CAACE,OAAO,GAAG,CAAC;EACpB,CAAC;EAED;;;;;;EAMAE,qBAAM,GAAN,UAAOD,MAAc;IACjB,IAAMQ,GAAG,GAAG,IAAIjB,UAAU,CAACS,MAAM,CAAC;IAClC,KAAK,IAAIS,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,GAAG,CAACR,MAAM,EAAES,CAAC,EAAE,EAAE;MACjC,IAAI,IAAI,CAACV,OAAO,KAAK,IAAI,CAACF,OAAO,CAACG,MAAM,EAAE;QACtC,IAAI,CAACU,WAAW,EAAE;;MAEtBF,GAAG,CAACC,CAAC,CAAC,GAAG,IAAI,CAACZ,OAAO,CAAC,IAAI,CAACE,OAAO,EAAE,CAAC;;IAEzC,OAAOS,GAAG;EACd,CAAC;EAEDP,oBAAK,GAAL;IACI,IAAI,CAACL,KAAK,CAACe,KAAK,EAAE;IAClBC,WAAI,CAAC,IAAI,CAACf,OAAO,CAAC;IAClBe,WAAI,CAAC,IAAI,CAACV,QAAQ,CAAC;IACnB,IAAI,CAACH,OAAO,GAAG,CAAC;EACpB,CAAC;EACL,WAAC;AAAD,CAAC,EA9FD;AAAac;AAgGb","names":["hash","key","salt","info","Uint8Array","_hash","_info","okm","hmac_1","_hmac","_buffer","digestLength","_bufpos","length","HKDF","_counter","ctr","Error","reset","update","finish","out","i","_fillBuffer","clean","wipe_1","exports"],"sources":["C:\\Users\\paete\\Prototype\\nftmusicprotocopy\\client\\node_modules\\@stablelib\\hkdf\\hkdf.ts"],"sourcesContent":["// Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\n\n/**\n * Package hkdf implements HKDF key derivation function.\n */\n\nimport { Hash } from \"@stablelib/hash\";\nimport { HMAC, hmac } from \"@stablelib/hmac\";\nimport { wipe } from \"@stablelib/wipe\";\n\n/**\n * HMAC-based Extract-and-Expand Key Derivation Function.\n *\n * Implements HKDF from RFC5869.\n *\n * Expands the given master key with salt and info into\n * a limited stream of key material.\n */\nexport class HKDF {\n    private _hmac: HMAC;\n    private _buffer: Uint8Array;\n    private _bufpos: number;\n    private _counter = new Uint8Array(1); // starts with zero\n    private _hash: new () => Hash;\n    private _info?: Uint8Array;\n\n    /**\n     * Create a new HKDF instance for the given hash function\n     * with the master key, optional salt, and info.\n     *\n     * - Master key is a high-entropy secret key (not a password).\n     * - Salt is a non-secret random value.\n     * - Info is application- and/or context-specific information.\n     */\n    constructor(hash: new () => Hash,\n        key: Uint8Array,\n        salt = new Uint8Array(0),\n        info?: Uint8Array) {\n\n        this._hash = hash;\n        this._info = info;\n\n        // HKDF-Extract uses salt as HMAC key, and key as data.\n        const okm = hmac(this._hash, salt, key);\n\n        // Initialize HMAC for expanding with extracted key.\n        this._hmac = new HMAC(hash, okm);\n\n        // Allocate buffer.\n        this._buffer = new Uint8Array(this._hmac.digestLength);\n        this._bufpos = this._buffer.length;\n    }\n\n    // Fill buffer with new block of HKDF-Extract output.\n    private _fillBuffer(): void {\n        // Increment counter.\n        this._counter[0]++;\n\n        const ctr = this._counter[0];\n\n        // Check if counter overflowed.\n        if (ctr === 0) {\n            throw new Error(\"hkdf: cannot expand more\");\n        }\n\n        // Prepare HMAC instance for new data with old key.\n        this._hmac.reset();\n\n        // Hash in previous output if it was generated\n        // (i.e. counter is greater than 1).\n        if (ctr > 1) {\n            this._hmac.update(this._buffer);\n        }\n\n        // Hash in info if it exists.\n        if (this._info) {\n            this._hmac.update(this._info);\n        }\n\n        // Hash in the counter.\n        this._hmac.update(this._counter);\n\n        // Output result to buffer and clean HMAC instance.\n        this._hmac.finish(this._buffer);\n\n        // Reset buffer position.\n        this._bufpos = 0;\n    }\n\n    /**\n     * Expand returns next key material of the given length.\n     *\n     * It throws if expansion limit is reached (which is\n     * 254 digests of the underlying HMAC function).\n     */\n    expand(length: number): Uint8Array {\n        const out = new Uint8Array(length);\n        for (let i = 0; i < out.length; i++) {\n            if (this._bufpos === this._buffer.length) {\n                this._fillBuffer();\n            }\n            out[i] = this._buffer[this._bufpos++];\n        }\n        return out;\n    }\n\n    clean(): void {\n        this._hmac.clean();\n        wipe(this._buffer);\n        wipe(this._counter);\n        this._bufpos = 0;\n    }\n}\n\n// TODO(dchest): maybe implement deriveKey?\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}