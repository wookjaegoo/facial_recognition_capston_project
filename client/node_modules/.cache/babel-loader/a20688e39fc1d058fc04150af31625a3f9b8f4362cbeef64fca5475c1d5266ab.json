{"ast":null,"code":"'use strict';\n\nconst {\n  AbortController\n} = require('native-abort-controller');\n\n/**\n * @typedef {import('ipfs-core-types/src/pubsub').MessageHandlerFn} MessageHandlerFn\n *\n * @typedef {Object} Subscription\n * @property {MessageHandlerFn} handler\n * @property {AbortController} controller\n */\n\nclass SubscriptionTracker {\n  constructor() {\n    /** @type {Map<string, Subscription[]>} */\n    this._subs = new Map();\n  }\n\n  /**\n   * @param {string} topic\n   * @param {MessageHandlerFn} handler\n   * @param {AbortSignal} [signal]\n   */\n  subscribe(topic, handler, signal) {\n    const topicSubs = this._subs.get(topic) || [];\n    if (topicSubs.find(s => s.handler === handler)) {\n      throw new Error(`Already subscribed to ${topic} with this handler`);\n    }\n\n    // Create controller so a call to unsubscribe can cancel the request\n    const controller = new AbortController();\n    this._subs.set(topic, [{\n      handler,\n      controller\n    }].concat(topicSubs));\n\n    // If there is an external signal, forward the abort event\n    if (signal) {\n      signal.addEventListener('abort', () => this.unsubscribe(topic, handler));\n    }\n    return controller.signal;\n  }\n\n  /**\n   * @param {string} topic\n   * @param {MessageHandlerFn} [handler]\n   */\n  unsubscribe(topic, handler) {\n    const subs = this._subs.get(topic) || [];\n    let unsubs;\n    if (handler) {\n      this._subs.set(topic, subs.filter(s => s.handler !== handler));\n      unsubs = subs.filter(s => s.handler === handler);\n    } else {\n      this._subs.set(topic, []);\n      unsubs = subs;\n    }\n    if (!(this._subs.get(topic) || []).length) {\n      this._subs.delete(topic);\n    }\n    unsubs.forEach(s => s.controller.abort());\n  }\n}\nmodule.exports = SubscriptionTracker;","map":{"version":3,"names":["AbortController","require","SubscriptionTracker","constructor","_subs","Map","subscribe","topic","handler","signal","topicSubs","get","find","s","Error","controller","set","concat","addEventListener","unsubscribe","subs","unsubs","filter","length","delete","forEach","abort","module","exports"],"sources":["C:/Users/paete/Prototype/nftmusicProtoCopy/client/node_modules/ipfs-http-client/src/pubsub/subscription-tracker.js"],"sourcesContent":["'use strict'\n\nconst { AbortController } = require('native-abort-controller')\n\n/**\n * @typedef {import('ipfs-core-types/src/pubsub').MessageHandlerFn} MessageHandlerFn\n *\n * @typedef {Object} Subscription\n * @property {MessageHandlerFn} handler\n * @property {AbortController} controller\n */\n\nclass SubscriptionTracker {\n  constructor () {\n    /** @type {Map<string, Subscription[]>} */\n    this._subs = new Map()\n  }\n\n  /**\n   * @param {string} topic\n   * @param {MessageHandlerFn} handler\n   * @param {AbortSignal} [signal]\n   */\n  subscribe (topic, handler, signal) {\n    const topicSubs = this._subs.get(topic) || []\n\n    if (topicSubs.find(s => s.handler === handler)) {\n      throw new Error(`Already subscribed to ${topic} with this handler`)\n    }\n\n    // Create controller so a call to unsubscribe can cancel the request\n    const controller = new AbortController()\n\n    this._subs.set(topic, [{ handler, controller }].concat(topicSubs))\n\n    // If there is an external signal, forward the abort event\n    if (signal) {\n      signal.addEventListener('abort', () => this.unsubscribe(topic, handler))\n    }\n\n    return controller.signal\n  }\n\n  /**\n   * @param {string} topic\n   * @param {MessageHandlerFn} [handler]\n   */\n  unsubscribe (topic, handler) {\n    const subs = this._subs.get(topic) || []\n    let unsubs\n\n    if (handler) {\n      this._subs.set(topic, subs.filter(s => s.handler !== handler))\n      unsubs = subs.filter(s => s.handler === handler)\n    } else {\n      this._subs.set(topic, [])\n      unsubs = subs\n    }\n\n    if (!(this._subs.get(topic) || []).length) {\n      this._subs.delete(topic)\n    }\n\n    unsubs.forEach(s => s.controller.abort())\n  }\n}\n\nmodule.exports = SubscriptionTracker\n"],"mappings":"AAAA,YAAY;;AAEZ,MAAM;EAAEA;AAAgB,CAAC,GAAGC,OAAO,CAAC,yBAAyB,CAAC;;AAE9D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMC,mBAAmB,CAAC;EACxBC,WAAW,GAAI;IACb;IACA,IAAI,CAACC,KAAK,GAAG,IAAIC,GAAG,EAAE;EACxB;;EAEA;AACF;AACA;AACA;AACA;EACEC,SAAS,CAAEC,KAAK,EAAEC,OAAO,EAAEC,MAAM,EAAE;IACjC,MAAMC,SAAS,GAAG,IAAI,CAACN,KAAK,CAACO,GAAG,CAACJ,KAAK,CAAC,IAAI,EAAE;IAE7C,IAAIG,SAAS,CAACE,IAAI,CAACC,CAAC,IAAIA,CAAC,CAACL,OAAO,KAAKA,OAAO,CAAC,EAAE;MAC9C,MAAM,IAAIM,KAAK,CAAE,yBAAwBP,KAAM,oBAAmB,CAAC;IACrE;;IAEA;IACA,MAAMQ,UAAU,GAAG,IAAIf,eAAe,EAAE;IAExC,IAAI,CAACI,KAAK,CAACY,GAAG,CAACT,KAAK,EAAE,CAAC;MAAEC,OAAO;MAAEO;IAAW,CAAC,CAAC,CAACE,MAAM,CAACP,SAAS,CAAC,CAAC;;IAElE;IACA,IAAID,MAAM,EAAE;MACVA,MAAM,CAACS,gBAAgB,CAAC,OAAO,EAAE,MAAM,IAAI,CAACC,WAAW,CAACZ,KAAK,EAAEC,OAAO,CAAC,CAAC;IAC1E;IAEA,OAAOO,UAAU,CAACN,MAAM;EAC1B;;EAEA;AACF;AACA;AACA;EACEU,WAAW,CAAEZ,KAAK,EAAEC,OAAO,EAAE;IAC3B,MAAMY,IAAI,GAAG,IAAI,CAAChB,KAAK,CAACO,GAAG,CAACJ,KAAK,CAAC,IAAI,EAAE;IACxC,IAAIc,MAAM;IAEV,IAAIb,OAAO,EAAE;MACX,IAAI,CAACJ,KAAK,CAACY,GAAG,CAACT,KAAK,EAAEa,IAAI,CAACE,MAAM,CAACT,CAAC,IAAIA,CAAC,CAACL,OAAO,KAAKA,OAAO,CAAC,CAAC;MAC9Da,MAAM,GAAGD,IAAI,CAACE,MAAM,CAACT,CAAC,IAAIA,CAAC,CAACL,OAAO,KAAKA,OAAO,CAAC;IAClD,CAAC,MAAM;MACL,IAAI,CAACJ,KAAK,CAACY,GAAG,CAACT,KAAK,EAAE,EAAE,CAAC;MACzBc,MAAM,GAAGD,IAAI;IACf;IAEA,IAAI,CAAC,CAAC,IAAI,CAAChB,KAAK,CAACO,GAAG,CAACJ,KAAK,CAAC,IAAI,EAAE,EAAEgB,MAAM,EAAE;MACzC,IAAI,CAACnB,KAAK,CAACoB,MAAM,CAACjB,KAAK,CAAC;IAC1B;IAEAc,MAAM,CAACI,OAAO,CAACZ,CAAC,IAAIA,CAAC,CAACE,UAAU,CAACW,KAAK,EAAE,CAAC;EAC3C;AACF;AAEAC,MAAM,CAACC,OAAO,GAAG1B,mBAAmB"},"metadata":{},"sourceType":"script","externalDependencies":[]}