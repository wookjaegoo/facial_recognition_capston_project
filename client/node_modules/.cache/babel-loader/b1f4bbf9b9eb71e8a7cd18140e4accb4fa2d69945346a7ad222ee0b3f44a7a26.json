{"ast":null,"code":"\"use strict\";\n\n// Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Package binary provides functions for encoding and decoding numbers in byte arrays.\n */\nvar int_1 = require(\"@stablelib/int\");\n// TODO(dchest): add asserts for correct value ranges and array offsets.\n/**\n * Reads 2 bytes from array starting at offset as big-endian\n * signed 16-bit integer and returns it.\n */\nfunction readInt16BE(array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n  return (array[offset + 0] << 8 | array[offset + 1]) << 16 >> 16;\n}\nexports.readInt16BE = readInt16BE;\n/**\n * Reads 2 bytes from array starting at offset as big-endian\n * unsigned 16-bit integer and returns it.\n */\nfunction readUint16BE(array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n  return (array[offset + 0] << 8 | array[offset + 1]) >>> 0;\n}\nexports.readUint16BE = readUint16BE;\n/**\n * Reads 2 bytes from array starting at offset as little-endian\n * signed 16-bit integer and returns it.\n */\nfunction readInt16LE(array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n  return (array[offset + 1] << 8 | array[offset]) << 16 >> 16;\n}\nexports.readInt16LE = readInt16LE;\n/**\n * Reads 2 bytes from array starting at offset as little-endian\n * unsigned 16-bit integer and returns it.\n */\nfunction readUint16LE(array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n  return (array[offset + 1] << 8 | array[offset]) >>> 0;\n}\nexports.readUint16LE = readUint16LE;\n/**\n * Writes 2-byte big-endian representation of 16-bit unsigned\n * value to byte array starting at offset.\n *\n * If byte array is not given, creates a new 2-byte one.\n *\n * Returns the output byte array.\n */\nfunction writeUint16BE(value, out, offset) {\n  if (out === void 0) {\n    out = new Uint8Array(2);\n  }\n  if (offset === void 0) {\n    offset = 0;\n  }\n  out[offset + 0] = value >>> 8;\n  out[offset + 1] = value >>> 0;\n  return out;\n}\nexports.writeUint16BE = writeUint16BE;\nexports.writeInt16BE = writeUint16BE;\n/**\n * Writes 2-byte little-endian representation of 16-bit unsigned\n * value to array starting at offset.\n *\n * If byte array is not given, creates a new 2-byte one.\n *\n * Returns the output byte array.\n */\nfunction writeUint16LE(value, out, offset) {\n  if (out === void 0) {\n    out = new Uint8Array(2);\n  }\n  if (offset === void 0) {\n    offset = 0;\n  }\n  out[offset + 0] = value >>> 0;\n  out[offset + 1] = value >>> 8;\n  return out;\n}\nexports.writeUint16LE = writeUint16LE;\nexports.writeInt16LE = writeUint16LE;\n/**\n * Reads 4 bytes from array starting at offset as big-endian\n * signed 32-bit integer and returns it.\n */\nfunction readInt32BE(array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n  return array[offset] << 24 | array[offset + 1] << 16 | array[offset + 2] << 8 | array[offset + 3];\n}\nexports.readInt32BE = readInt32BE;\n/**\n * Reads 4 bytes from array starting at offset as big-endian\n * unsigned 32-bit integer and returns it.\n */\nfunction readUint32BE(array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n  return (array[offset] << 24 | array[offset + 1] << 16 | array[offset + 2] << 8 | array[offset + 3]) >>> 0;\n}\nexports.readUint32BE = readUint32BE;\n/**\n * Reads 4 bytes from array starting at offset as little-endian\n * signed 32-bit integer and returns it.\n */\nfunction readInt32LE(array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n  return array[offset + 3] << 24 | array[offset + 2] << 16 | array[offset + 1] << 8 | array[offset];\n}\nexports.readInt32LE = readInt32LE;\n/**\n * Reads 4 bytes from array starting at offset as little-endian\n * unsigned 32-bit integer and returns it.\n */\nfunction readUint32LE(array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n  return (array[offset + 3] << 24 | array[offset + 2] << 16 | array[offset + 1] << 8 | array[offset]) >>> 0;\n}\nexports.readUint32LE = readUint32LE;\n/**\n * Writes 4-byte big-endian representation of 32-bit unsigned\n * value to byte array starting at offset.\n *\n * If byte array is not given, creates a new 4-byte one.\n *\n * Returns the output byte array.\n */\nfunction writeUint32BE(value, out, offset) {\n  if (out === void 0) {\n    out = new Uint8Array(4);\n  }\n  if (offset === void 0) {\n    offset = 0;\n  }\n  out[offset + 0] = value >>> 24;\n  out[offset + 1] = value >>> 16;\n  out[offset + 2] = value >>> 8;\n  out[offset + 3] = value >>> 0;\n  return out;\n}\nexports.writeUint32BE = writeUint32BE;\nexports.writeInt32BE = writeUint32BE;\n/**\n * Writes 4-byte little-endian representation of 32-bit unsigned\n * value to array starting at offset.\n *\n * If byte array is not given, creates a new 4-byte one.\n *\n * Returns the output byte array.\n */\nfunction writeUint32LE(value, out, offset) {\n  if (out === void 0) {\n    out = new Uint8Array(4);\n  }\n  if (offset === void 0) {\n    offset = 0;\n  }\n  out[offset + 0] = value >>> 0;\n  out[offset + 1] = value >>> 8;\n  out[offset + 2] = value >>> 16;\n  out[offset + 3] = value >>> 24;\n  return out;\n}\nexports.writeUint32LE = writeUint32LE;\nexports.writeInt32LE = writeUint32LE;\n/**\n * Reads 8 bytes from array starting at offset as big-endian\n * signed 64-bit integer and returns it.\n *\n * IMPORTANT: due to JavaScript limitation, supports exact\n * numbers in range -9007199254740991 to 9007199254740991.\n * If the number stored in the byte array is outside this range,\n * the result is not exact.\n */\nfunction readInt64BE(array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n  var hi = readInt32BE(array, offset);\n  var lo = readInt32BE(array, offset + 4);\n  return hi * 0x100000000 + lo - (lo >> 31) * 0x100000000;\n}\nexports.readInt64BE = readInt64BE;\n/**\n * Reads 8 bytes from array starting at offset as big-endian\n * unsigned 64-bit integer and returns it.\n *\n * IMPORTANT: due to JavaScript limitation, supports values up to 2^53-1.\n */\nfunction readUint64BE(array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n  var hi = readUint32BE(array, offset);\n  var lo = readUint32BE(array, offset + 4);\n  return hi * 0x100000000 + lo;\n}\nexports.readUint64BE = readUint64BE;\n/**\n * Reads 8 bytes from array starting at offset as little-endian\n * signed 64-bit integer and returns it.\n *\n * IMPORTANT: due to JavaScript limitation, supports exact\n * numbers in range -9007199254740991 to 9007199254740991.\n * If the number stored in the byte array is outside this range,\n * the result is not exact.\n */\nfunction readInt64LE(array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n  var lo = readInt32LE(array, offset);\n  var hi = readInt32LE(array, offset + 4);\n  return hi * 0x100000000 + lo - (lo >> 31) * 0x100000000;\n}\nexports.readInt64LE = readInt64LE;\n/**\n * Reads 8 bytes from array starting at offset as little-endian\n * unsigned 64-bit integer and returns it.\n *\n * IMPORTANT: due to JavaScript limitation, supports values up to 2^53-1.\n */\nfunction readUint64LE(array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n  var lo = readUint32LE(array, offset);\n  var hi = readUint32LE(array, offset + 4);\n  return hi * 0x100000000 + lo;\n}\nexports.readUint64LE = readUint64LE;\n/**\n * Writes 8-byte big-endian representation of 64-bit unsigned\n * value to byte array starting at offset.\n *\n * Due to JavaScript limitation, supports values up to 2^53-1.\n *\n * If byte array is not given, creates a new 8-byte one.\n *\n * Returns the output byte array.\n */\nfunction writeUint64BE(value, out, offset) {\n  if (out === void 0) {\n    out = new Uint8Array(8);\n  }\n  if (offset === void 0) {\n    offset = 0;\n  }\n  writeUint32BE(value / 0x100000000 >>> 0, out, offset);\n  writeUint32BE(value >>> 0, out, offset + 4);\n  return out;\n}\nexports.writeUint64BE = writeUint64BE;\nexports.writeInt64BE = writeUint64BE;\n/**\n * Writes 8-byte little-endian representation of 64-bit unsigned\n * value to byte array starting at offset.\n *\n * Due to JavaScript limitation, supports values up to 2^53-1.\n *\n * If byte array is not given, creates a new 8-byte one.\n *\n * Returns the output byte array.\n */\nfunction writeUint64LE(value, out, offset) {\n  if (out === void 0) {\n    out = new Uint8Array(8);\n  }\n  if (offset === void 0) {\n    offset = 0;\n  }\n  writeUint32LE(value >>> 0, out, offset);\n  writeUint32LE(value / 0x100000000 >>> 0, out, offset + 4);\n  return out;\n}\nexports.writeUint64LE = writeUint64LE;\nexports.writeInt64LE = writeUint64LE;\n/**\n * Reads bytes from array starting at offset as big-endian\n * unsigned bitLen-bit integer and returns it.\n *\n * Supports bit lengths divisible by 8, up to 48.\n */\nfunction readUintBE(bitLength, array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n  // TODO(dchest): implement support for bitLengths non-divisible by 8\n  if (bitLength % 8 !== 0) {\n    throw new Error(\"readUintBE supports only bitLengths divisible by 8\");\n  }\n  if (bitLength / 8 > array.length - offset) {\n    throw new Error(\"readUintBE: array is too short for the given bitLength\");\n  }\n  var result = 0;\n  var mul = 1;\n  for (var i = bitLength / 8 + offset - 1; i >= offset; i--) {\n    result += array[i] * mul;\n    mul *= 256;\n  }\n  return result;\n}\nexports.readUintBE = readUintBE;\n/**\n * Reads bytes from array starting at offset as little-endian\n * unsigned bitLen-bit integer and returns it.\n *\n * Supports bit lengths divisible by 8, up to 48.\n */\nfunction readUintLE(bitLength, array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n  // TODO(dchest): implement support for bitLengths non-divisible by 8\n  if (bitLength % 8 !== 0) {\n    throw new Error(\"readUintLE supports only bitLengths divisible by 8\");\n  }\n  if (bitLength / 8 > array.length - offset) {\n    throw new Error(\"readUintLE: array is too short for the given bitLength\");\n  }\n  var result = 0;\n  var mul = 1;\n  for (var i = offset; i < offset + bitLength / 8; i++) {\n    result += array[i] * mul;\n    mul *= 256;\n  }\n  return result;\n}\nexports.readUintLE = readUintLE;\n/**\n * Writes a big-endian representation of bitLen-bit unsigned\n * value to array starting at offset.\n *\n * Supports bit lengths divisible by 8, up to 48.\n *\n * If byte array is not given, creates a new one.\n *\n * Returns the output byte array.\n */\nfunction writeUintBE(bitLength, value, out, offset) {\n  if (out === void 0) {\n    out = new Uint8Array(bitLength / 8);\n  }\n  if (offset === void 0) {\n    offset = 0;\n  }\n  // TODO(dchest): implement support for bitLengths non-divisible by 8\n  if (bitLength % 8 !== 0) {\n    throw new Error(\"writeUintBE supports only bitLengths divisible by 8\");\n  }\n  if (!int_1.isSafeInteger(value)) {\n    throw new Error(\"writeUintBE value must be an integer\");\n  }\n  var div = 1;\n  for (var i = bitLength / 8 + offset - 1; i >= offset; i--) {\n    out[i] = value / div & 0xff;\n    div *= 256;\n  }\n  return out;\n}\nexports.writeUintBE = writeUintBE;\n/**\n * Writes a little-endian representation of bitLen-bit unsigned\n * value to array starting at offset.\n *\n * Supports bit lengths divisible by 8, up to 48.\n *\n * If byte array is not given, creates a new one.\n *\n * Returns the output byte array.\n */\nfunction writeUintLE(bitLength, value, out, offset) {\n  if (out === void 0) {\n    out = new Uint8Array(bitLength / 8);\n  }\n  if (offset === void 0) {\n    offset = 0;\n  }\n  // TODO(dchest): implement support for bitLengths non-divisible by 8\n  if (bitLength % 8 !== 0) {\n    throw new Error(\"writeUintLE supports only bitLengths divisible by 8\");\n  }\n  if (!int_1.isSafeInteger(value)) {\n    throw new Error(\"writeUintLE value must be an integer\");\n  }\n  var div = 1;\n  for (var i = offset; i < offset + bitLength / 8; i++) {\n    out[i] = value / div & 0xff;\n    div *= 256;\n  }\n  return out;\n}\nexports.writeUintLE = writeUintLE;\n/**\n * Reads 4 bytes from array starting at offset as big-endian\n * 32-bit floating-point number and returns it.\n */\nfunction readFloat32BE(array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n  var view = new DataView(array.buffer, array.byteOffset, array.byteLength);\n  return view.getFloat32(offset);\n}\nexports.readFloat32BE = readFloat32BE;\n/**\n * Reads 4 bytes from array starting at offset as little-endian\n * 32-bit floating-point number and returns it.\n */\nfunction readFloat32LE(array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n  var view = new DataView(array.buffer, array.byteOffset, array.byteLength);\n  return view.getFloat32(offset, true);\n}\nexports.readFloat32LE = readFloat32LE;\n/**\n * Reads 8 bytes from array starting at offset as big-endian\n * 64-bit floating-point number (\"double\") and returns it.\n */\nfunction readFloat64BE(array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n  var view = new DataView(array.buffer, array.byteOffset, array.byteLength);\n  return view.getFloat64(offset);\n}\nexports.readFloat64BE = readFloat64BE;\n/**\n * Reads 8 bytes from array starting at offset as little-endian\n * 64-bit floating-point number (\"double\") and returns it.\n */\nfunction readFloat64LE(array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n  var view = new DataView(array.buffer, array.byteOffset, array.byteLength);\n  return view.getFloat64(offset, true);\n}\nexports.readFloat64LE = readFloat64LE;\n/**\n * Writes 4-byte big-endian floating-point representation of value\n * to byte array starting at offset.\n *\n * If byte array is not given, creates a new 4-byte one.\n *\n * Returns the output byte array.\n */\nfunction writeFloat32BE(value, out, offset) {\n  if (out === void 0) {\n    out = new Uint8Array(4);\n  }\n  if (offset === void 0) {\n    offset = 0;\n  }\n  var view = new DataView(out.buffer, out.byteOffset, out.byteLength);\n  view.setFloat32(offset, value);\n  return out;\n}\nexports.writeFloat32BE = writeFloat32BE;\n/**\n * Writes 4-byte little-endian floating-point representation of value\n * to byte array starting at offset.\n *\n * If byte array is not given, creates a new 4-byte one.\n *\n * Returns the output byte array.\n */\nfunction writeFloat32LE(value, out, offset) {\n  if (out === void 0) {\n    out = new Uint8Array(4);\n  }\n  if (offset === void 0) {\n    offset = 0;\n  }\n  var view = new DataView(out.buffer, out.byteOffset, out.byteLength);\n  view.setFloat32(offset, value, true);\n  return out;\n}\nexports.writeFloat32LE = writeFloat32LE;\n/**\n * Writes 8-byte big-endian floating-point representation of value\n * to byte array starting at offset.\n *\n * If byte array is not given, creates a new 8-byte one.\n *\n * Returns the output byte array.\n */\nfunction writeFloat64BE(value, out, offset) {\n  if (out === void 0) {\n    out = new Uint8Array(8);\n  }\n  if (offset === void 0) {\n    offset = 0;\n  }\n  var view = new DataView(out.buffer, out.byteOffset, out.byteLength);\n  view.setFloat64(offset, value);\n  return out;\n}\nexports.writeFloat64BE = writeFloat64BE;\n/**\n * Writes 8-byte little-endian floating-point representation of value\n * to byte array starting at offset.\n *\n * If byte array is not given, creates a new 8-byte one.\n *\n * Returns the output byte array.\n */\nfunction writeFloat64LE(value, out, offset) {\n  if (out === void 0) {\n    out = new Uint8Array(8);\n  }\n  if (offset === void 0) {\n    offset = 0;\n  }\n  var view = new DataView(out.buffer, out.byteOffset, out.byteLength);\n  view.setFloat64(offset, value, true);\n  return out;\n}\nexports.writeFloat64LE = writeFloat64LE;","map":{"version":3,"mappings":";;AAAA;AACA;;;;AAEA;;;AAIA;AAEA;AAEA;;;;AAIA,SAAgBA,WAAW,CAACC,KAAiB,EAAEC,MAAU;EAAV;IAAAA,UAAU;EAAA;EACrD,OAAQ,CAAED,KAAK,CAACC,MAAM,GAAG,CAAC,CAAC,IAAI,CAAC,GAAID,KAAK,CAACC,MAAM,GAAG,CAAC,CAAC,KAAK,EAAE,IAAK,EAAE;AACvE;AAFAC;AAIA;;;;AAIA,SAAgBC,YAAY,CAACH,KAAiB,EAAEC,MAAU;EAAV;IAAAA,UAAU;EAAA;EACtD,OAAO,CAAED,KAAK,CAACC,MAAM,GAAG,CAAC,CAAC,IAAI,CAAC,GAAID,KAAK,CAACC,MAAM,GAAG,CAAC,CAAC,MAAM,CAAC;AAC/D;AAFAC;AAIA;;;;AAIA,SAAgBE,WAAW,CAACJ,KAAiB,EAAEC,MAAU;EAAV;IAAAA,UAAU;EAAA;EACrD,OAAQ,CAAED,KAAK,CAACC,MAAM,GAAG,CAAC,CAAC,IAAI,CAAC,GAAID,KAAK,CAACC,MAAM,CAAC,KAAK,EAAE,IAAK,EAAE;AACnE;AAFAC;AAIA;;;;AAIA,SAAgBG,YAAY,CAACL,KAAiB,EAAEC,MAAU;EAAV;IAAAA,UAAU;EAAA;EACtD,OAAO,CAAED,KAAK,CAACC,MAAM,GAAG,CAAC,CAAC,IAAI,CAAC,GAAID,KAAK,CAACC,MAAM,CAAC,MAAM,CAAC;AAC3D;AAFAC;AAIA;;;;;;;;AAQA,SAAgBI,aAAa,CAACC,KAAa,EAAEC,GAAuB,EAAEP,MAAU;EAAnC;IAAAO,UAAUC,UAAU,CAAC,CAAC,CAAC;EAAA;EAAE;IAAAR,UAAU;EAAA;EAC5EO,GAAG,CAACP,MAAM,GAAG,CAAC,CAAC,GAAGM,KAAK,KAAK,CAAC;EAC7BC,GAAG,CAACP,MAAM,GAAG,CAAC,CAAC,GAAGM,KAAK,KAAK,CAAC;EAC7B,OAAOC,GAAG;AACd;AAJAN;AAMaA,oBAAY,GAAGI,aAAa;AAEzC;;;;;;;;AAQA,SAAgBI,aAAa,CAACH,KAAa,EAAEC,GAAuB,EAAEP,MAAU;EAAnC;IAAAO,UAAUC,UAAU,CAAC,CAAC,CAAC;EAAA;EAAE;IAAAR,UAAU;EAAA;EAC5EO,GAAG,CAACP,MAAM,GAAG,CAAC,CAAC,GAAGM,KAAK,KAAK,CAAC;EAC7BC,GAAG,CAACP,MAAM,GAAG,CAAC,CAAC,GAAGM,KAAK,KAAK,CAAC;EAC7B,OAAOC,GAAG;AACd;AAJAN;AAMaA,oBAAY,GAAGQ,aAAa;AAEzC;;;;AAIA,SAAgBC,WAAW,CAACX,KAAiB,EAAEC,MAAU;EAAV;IAAAA,UAAU;EAAA;EACrD,OAAQD,KAAK,CAACC,MAAM,CAAC,IAAI,EAAE,GACtBD,KAAK,CAACC,MAAM,GAAG,CAAC,CAAC,IAAI,EAAG,GACxBD,KAAK,CAACC,MAAM,GAAG,CAAC,CAAC,IAAI,CAAE,GACxBD,KAAK,CAACC,MAAM,GAAG,CAAC,CAAC;AACzB;AALAC;AAOA;;;;AAIA,SAAgBU,YAAY,CAACZ,KAAiB,EAAEC,MAAU;EAAV;IAAAA,UAAU;EAAA;EACtD,OAAO,CAAED,KAAK,CAACC,MAAM,CAAC,IAAI,EAAE,GACvBD,KAAK,CAACC,MAAM,GAAG,CAAC,CAAC,IAAI,EAAG,GACxBD,KAAK,CAACC,MAAM,GAAG,CAAC,CAAC,IAAI,CAAE,GACxBD,KAAK,CAACC,MAAM,GAAG,CAAC,CAAC,MAAM,CAAC;AAChC;AALAC;AAOA;;;;AAIA,SAAgBW,WAAW,CAACb,KAAiB,EAAEC,MAAU;EAAV;IAAAA,UAAU;EAAA;EACrD,OAAQD,KAAK,CAACC,MAAM,GAAG,CAAC,CAAC,IAAI,EAAE,GAC1BD,KAAK,CAACC,MAAM,GAAG,CAAC,CAAC,IAAI,EAAG,GACxBD,KAAK,CAACC,MAAM,GAAG,CAAC,CAAC,IAAI,CAAE,GACxBD,KAAK,CAACC,MAAM,CAAC;AACrB;AALAC;AAOA;;;;AAIA,SAAgBY,YAAY,CAACd,KAAiB,EAAEC,MAAU;EAAV;IAAAA,UAAU;EAAA;EACtD,OAAO,CAAED,KAAK,CAACC,MAAM,GAAG,CAAC,CAAC,IAAI,EAAE,GAC3BD,KAAK,CAACC,MAAM,GAAG,CAAC,CAAC,IAAI,EAAG,GACxBD,KAAK,CAACC,MAAM,GAAG,CAAC,CAAC,IAAI,CAAE,GACxBD,KAAK,CAACC,MAAM,CAAC,MAAM,CAAC;AAC5B;AALAC;AAOA;;;;;;;;AAQA,SAAgBa,aAAa,CAACR,KAAa,EAAEC,GAAuB,EAAEP,MAAU;EAAnC;IAAAO,UAAUC,UAAU,CAAC,CAAC,CAAC;EAAA;EAAE;IAAAR,UAAU;EAAA;EAC5EO,GAAG,CAACP,MAAM,GAAG,CAAC,CAAC,GAAGM,KAAK,KAAK,EAAE;EAC9BC,GAAG,CAACP,MAAM,GAAG,CAAC,CAAC,GAAGM,KAAK,KAAK,EAAE;EAC9BC,GAAG,CAACP,MAAM,GAAG,CAAC,CAAC,GAAGM,KAAK,KAAK,CAAC;EAC7BC,GAAG,CAACP,MAAM,GAAG,CAAC,CAAC,GAAGM,KAAK,KAAK,CAAC;EAC7B,OAAOC,GAAG;AACd;AANAN;AAQaA,oBAAY,GAAGa,aAAa;AAEzC;;;;;;;;AAQA,SAAgBC,aAAa,CAACT,KAAa,EAAEC,GAAuB,EAAEP,MAAU;EAAnC;IAAAO,UAAUC,UAAU,CAAC,CAAC,CAAC;EAAA;EAAE;IAAAR,UAAU;EAAA;EAC5EO,GAAG,CAACP,MAAM,GAAG,CAAC,CAAC,GAAGM,KAAK,KAAK,CAAC;EAC7BC,GAAG,CAACP,MAAM,GAAG,CAAC,CAAC,GAAGM,KAAK,KAAK,CAAC;EAC7BC,GAAG,CAACP,MAAM,GAAG,CAAC,CAAC,GAAGM,KAAK,KAAK,EAAE;EAC9BC,GAAG,CAACP,MAAM,GAAG,CAAC,CAAC,GAAGM,KAAK,KAAK,EAAE;EAC9B,OAAOC,GAAG;AACd;AANAN;AASaA,oBAAY,GAAGc,aAAa;AAEzC;;;;;;;;;AASA,SAAgBC,WAAW,CAACjB,KAAiB,EAAEC,MAAU;EAAV;IAAAA,UAAU;EAAA;EACrD,IAAMiB,EAAE,GAAGP,WAAW,CAACX,KAAK,EAAEC,MAAM,CAAC;EACrC,IAAMkB,EAAE,GAAGR,WAAW,CAACX,KAAK,EAAEC,MAAM,GAAG,CAAC,CAAC;EACzC,OAAOiB,EAAE,GAAG,WAAW,GAAGC,EAAE,GAAI,CAACA,EAAE,IAAE,EAAE,IAAI,WAAY;AAC3D;AAJAjB;AAMA;;;;;;AAMA,SAAgBkB,YAAY,CAACpB,KAAiB,EAAEC,MAAU;EAAV;IAAAA,UAAU;EAAA;EACtD,IAAMiB,EAAE,GAAGN,YAAY,CAACZ,KAAK,EAAEC,MAAM,CAAC;EACtC,IAAMkB,EAAE,GAAGP,YAAY,CAACZ,KAAK,EAAEC,MAAM,GAAG,CAAC,CAAC;EAC1C,OAAOiB,EAAE,GAAG,WAAW,GAAGC,EAAE;AAChC;AAJAjB;AAMA;;;;;;;;;AASA,SAAgBmB,WAAW,CAACrB,KAAiB,EAAEC,MAAU;EAAV;IAAAA,UAAU;EAAA;EACrD,IAAMkB,EAAE,GAAGN,WAAW,CAACb,KAAK,EAAEC,MAAM,CAAC;EACrC,IAAMiB,EAAE,GAAGL,WAAW,CAACb,KAAK,EAAEC,MAAM,GAAG,CAAC,CAAC;EACzC,OAAOiB,EAAE,GAAG,WAAW,GAAGC,EAAE,GAAI,CAACA,EAAE,IAAE,EAAE,IAAI,WAAY;AAC3D;AAJAjB;AAOA;;;;;;AAMA,SAAgBoB,YAAY,CAACtB,KAAiB,EAAEC,MAAU;EAAV;IAAAA,UAAU;EAAA;EACtD,IAAMkB,EAAE,GAAGL,YAAY,CAACd,KAAK,EAAEC,MAAM,CAAC;EACtC,IAAMiB,EAAE,GAAGJ,YAAY,CAACd,KAAK,EAAEC,MAAM,GAAG,CAAC,CAAC;EAC1C,OAAOiB,EAAE,GAAG,WAAW,GAAGC,EAAE;AAChC;AAJAjB;AAMA;;;;;;;;;;AAUA,SAAgBqB,aAAa,CAAChB,KAAa,EAAEC,GAAuB,EAAEP,MAAU;EAAnC;IAAAO,UAAUC,UAAU,CAAC,CAAC,CAAC;EAAA;EAAE;IAAAR,UAAU;EAAA;EAC5Ec,aAAa,CAACR,KAAK,GAAG,WAAW,KAAK,CAAC,EAAEC,GAAG,EAAEP,MAAM,CAAC;EACrDc,aAAa,CAACR,KAAK,KAAK,CAAC,EAAEC,GAAG,EAAEP,MAAM,GAAG,CAAC,CAAC;EAC3C,OAAOO,GAAG;AACd;AAJAN;AAMaA,oBAAY,GAAGqB,aAAa;AAEzC;;;;;;;;;;AAUA,SAAgBC,aAAa,CAACjB,KAAa,EAAEC,GAAuB,EAAEP,MAAU;EAAnC;IAAAO,UAAUC,UAAU,CAAC,CAAC,CAAC;EAAA;EAAE;IAAAR,UAAU;EAAA;EAC5Ee,aAAa,CAACT,KAAK,KAAK,CAAC,EAAEC,GAAG,EAAEP,MAAM,CAAC;EACvCe,aAAa,CAACT,KAAK,GAAG,WAAW,KAAK,CAAC,EAAEC,GAAG,EAAEP,MAAM,GAAG,CAAC,CAAC;EACzD,OAAOO,GAAG;AACd;AAJAN;AAMaA,oBAAY,GAAGsB,aAAa;AAEzC;;;;;;AAMA,SAAgBC,UAAU,CAACC,SAAiB,EAAE1B,KAAiB,EAAEC,MAAU;EAAV;IAAAA,UAAU;EAAA;EACvE;EACA,IAAIyB,SAAS,GAAG,CAAC,KAAK,CAAC,EAAE;IACrB,MAAM,IAAIC,KAAK,CAAC,oDAAoD,CAAC;;EAEzE,IAAID,SAAS,GAAG,CAAC,GAAG1B,KAAK,CAAC4B,MAAM,GAAG3B,MAAM,EAAE;IACvC,MAAM,IAAI0B,KAAK,CAAC,wDAAwD,CAAC;;EAE7E,IAAIE,MAAM,GAAG,CAAC;EACd,IAAIC,GAAG,GAAG,CAAC;EACX,KAAK,IAAIC,CAAC,GAAGL,SAAS,GAAG,CAAC,GAAGzB,MAAM,GAAG,CAAC,EAAE8B,CAAC,IAAI9B,MAAM,EAAE8B,CAAC,EAAE,EAAE;IACvDF,MAAM,IAAI7B,KAAK,CAAC+B,CAAC,CAAC,GAAGD,GAAG;IACxBA,GAAG,IAAI,GAAG;;EAEd,OAAOD,MAAM;AACjB;AAfA3B;AAiBA;;;;;;AAMA,SAAgB8B,UAAU,CAACN,SAAiB,EAAE1B,KAAiB,EAAEC,MAAU;EAAV;IAAAA,UAAU;EAAA;EACvE;EACA,IAAIyB,SAAS,GAAG,CAAC,KAAK,CAAC,EAAE;IACrB,MAAM,IAAIC,KAAK,CAAC,oDAAoD,CAAC;;EAEzE,IAAID,SAAS,GAAG,CAAC,GAAG1B,KAAK,CAAC4B,MAAM,GAAG3B,MAAM,EAAE;IACvC,MAAM,IAAI0B,KAAK,CAAC,wDAAwD,CAAC;;EAE7E,IAAIE,MAAM,GAAG,CAAC;EACd,IAAIC,GAAG,GAAG,CAAC;EACX,KAAK,IAAIC,CAAC,GAAG9B,MAAM,EAAE8B,CAAC,GAAG9B,MAAM,GAAGyB,SAAS,GAAG,CAAC,EAAEK,CAAC,EAAE,EAAE;IAClDF,MAAM,IAAI7B,KAAK,CAAC+B,CAAC,CAAC,GAAGD,GAAG;IACxBA,GAAG,IAAI,GAAG;;EAEd,OAAOD,MAAM;AACjB;AAfA3B;AAiBA;;;;;;;;;;AAUA,SAAgB+B,WAAW,CAACP,SAAiB,EAAEnB,KAAa,EACxDC,GAAmC,EAAEP,MAAU;EAA/C;IAAAO,UAAUC,UAAU,CAACiB,SAAS,GAAG,CAAC,CAAC;EAAA;EAAE;IAAAzB,UAAU;EAAA;EAC/C;EACA,IAAIyB,SAAS,GAAG,CAAC,KAAK,CAAC,EAAE;IACrB,MAAM,IAAIC,KAAK,CAAC,qDAAqD,CAAC;;EAE1E,IAAI,CAACO,mBAAa,CAAC3B,KAAK,CAAC,EAAE;IACvB,MAAM,IAAIoB,KAAK,CAAC,sCAAsC,CAAC;;EAE3D,IAAIQ,GAAG,GAAG,CAAC;EACX,KAAK,IAAIJ,CAAC,GAAGL,SAAS,GAAG,CAAC,GAAGzB,MAAM,GAAG,CAAC,EAAE8B,CAAC,IAAI9B,MAAM,EAAE8B,CAAC,EAAE,EAAE;IACvDvB,GAAG,CAACuB,CAAC,CAAC,GAAIxB,KAAK,GAAG4B,GAAG,GAAI,IAAI;IAC7BA,GAAG,IAAI,GAAG;;EAEd,OAAO3B,GAAG;AACd;AAfAN;AAiBA;;;;;;;;;;AAUA,SAAgBkC,WAAW,CAACV,SAAiB,EAAEnB,KAAa,EACxDC,GAAmC,EAAEP,MAAU;EAA/C;IAAAO,UAAUC,UAAU,CAACiB,SAAS,GAAG,CAAC,CAAC;EAAA;EAAE;IAAAzB,UAAU;EAAA;EAC/C;EACA,IAAIyB,SAAS,GAAG,CAAC,KAAK,CAAC,EAAE;IACrB,MAAM,IAAIC,KAAK,CAAC,qDAAqD,CAAC;;EAE1E,IAAI,CAACO,mBAAa,CAAC3B,KAAK,CAAC,EAAE;IACvB,MAAM,IAAIoB,KAAK,CAAC,sCAAsC,CAAC;;EAE3D,IAAIQ,GAAG,GAAG,CAAC;EACX,KAAK,IAAIJ,CAAC,GAAG9B,MAAM,EAAE8B,CAAC,GAAG9B,MAAM,GAAGyB,SAAS,GAAG,CAAC,EAAEK,CAAC,EAAE,EAAE;IAClDvB,GAAG,CAACuB,CAAC,CAAC,GAAIxB,KAAK,GAAG4B,GAAG,GAAI,IAAI;IAC7BA,GAAG,IAAI,GAAG;;EAEd,OAAO3B,GAAG;AACd;AAfAN;AAiBA;;;;AAIA,SAAgBmC,aAAa,CAACrC,KAAiB,EAAEC,MAAU;EAAV;IAAAA,UAAU;EAAA;EACvD,IAAMqC,IAAI,GAAG,IAAIC,QAAQ,CAACvC,KAAK,CAACwC,MAAM,EAAExC,KAAK,CAACyC,UAAU,EAAEzC,KAAK,CAAC0C,UAAU,CAAC;EAC3E,OAAOJ,IAAI,CAACK,UAAU,CAAC1C,MAAM,CAAC;AAClC;AAHAC;AAKA;;;;AAIA,SAAgB0C,aAAa,CAAC5C,KAAiB,EAAEC,MAAU;EAAV;IAAAA,UAAU;EAAA;EACvD,IAAMqC,IAAI,GAAG,IAAIC,QAAQ,CAACvC,KAAK,CAACwC,MAAM,EAAExC,KAAK,CAACyC,UAAU,EAAEzC,KAAK,CAAC0C,UAAU,CAAC;EAC3E,OAAOJ,IAAI,CAACK,UAAU,CAAC1C,MAAM,EAAE,IAAI,CAAC;AACxC;AAHAC;AAKA;;;;AAIA,SAAgB2C,aAAa,CAAC7C,KAAiB,EAAEC,MAAU;EAAV;IAAAA,UAAU;EAAA;EACvD,IAAMqC,IAAI,GAAG,IAAIC,QAAQ,CAACvC,KAAK,CAACwC,MAAM,EAAExC,KAAK,CAACyC,UAAU,EAAEzC,KAAK,CAAC0C,UAAU,CAAC;EAC3E,OAAOJ,IAAI,CAACQ,UAAU,CAAC7C,MAAM,CAAC;AAClC;AAHAC;AAKA;;;;AAIA,SAAgB6C,aAAa,CAAC/C,KAAiB,EAAEC,MAAU;EAAV;IAAAA,UAAU;EAAA;EACvD,IAAMqC,IAAI,GAAG,IAAIC,QAAQ,CAACvC,KAAK,CAACwC,MAAM,EAAExC,KAAK,CAACyC,UAAU,EAAEzC,KAAK,CAAC0C,UAAU,CAAC;EAC3E,OAAOJ,IAAI,CAACQ,UAAU,CAAC7C,MAAM,EAAE,IAAI,CAAC;AACxC;AAHAC;AAKA;;;;;;;;AAQA,SAAgB8C,cAAc,CAACzC,KAAa,EAAEC,GAAuB,EAAEP,MAAU;EAAnC;IAAAO,UAAUC,UAAU,CAAC,CAAC,CAAC;EAAA;EAAE;IAAAR,UAAU;EAAA;EAC7E,IAAMqC,IAAI,GAAG,IAAIC,QAAQ,CAAC/B,GAAG,CAACgC,MAAM,EAAEhC,GAAG,CAACiC,UAAU,EAAEjC,GAAG,CAACkC,UAAU,CAAC;EACrEJ,IAAI,CAACW,UAAU,CAAChD,MAAM,EAAEM,KAAK,CAAC;EAC9B,OAAOC,GAAG;AACd;AAJAN;AAMA;;;;;;;;AAQA,SAAgBgD,cAAc,CAAC3C,KAAa,EAAEC,GAAuB,EAAEP,MAAU;EAAnC;IAAAO,UAAUC,UAAU,CAAC,CAAC,CAAC;EAAA;EAAE;IAAAR,UAAU;EAAA;EAC7E,IAAMqC,IAAI,GAAG,IAAIC,QAAQ,CAAC/B,GAAG,CAACgC,MAAM,EAAEhC,GAAG,CAACiC,UAAU,EAAEjC,GAAG,CAACkC,UAAU,CAAC;EACrEJ,IAAI,CAACW,UAAU,CAAChD,MAAM,EAAEM,KAAK,EAAE,IAAI,CAAC;EACpC,OAAOC,GAAG;AACd;AAJAN;AAMA;;;;;;;;AAQA,SAAgBiD,cAAc,CAAC5C,KAAa,EAAEC,GAAuB,EAAEP,MAAU;EAAnC;IAAAO,UAAUC,UAAU,CAAC,CAAC,CAAC;EAAA;EAAE;IAAAR,UAAU;EAAA;EAC7E,IAAMqC,IAAI,GAAG,IAAIC,QAAQ,CAAC/B,GAAG,CAACgC,MAAM,EAAEhC,GAAG,CAACiC,UAAU,EAAEjC,GAAG,CAACkC,UAAU,CAAC;EACrEJ,IAAI,CAACc,UAAU,CAACnD,MAAM,EAAEM,KAAK,CAAC;EAC9B,OAAOC,GAAG;AACd;AAJAN;AAMA;;;;;;;;AAQA,SAAgBmD,cAAc,CAAC9C,KAAa,EAAEC,GAAuB,EAAEP,MAAU;EAAnC;IAAAO,UAAUC,UAAU,CAAC,CAAC,CAAC;EAAA;EAAE;IAAAR,UAAU;EAAA;EAC7E,IAAMqC,IAAI,GAAG,IAAIC,QAAQ,CAAC/B,GAAG,CAACgC,MAAM,EAAEhC,GAAG,CAACiC,UAAU,EAAEjC,GAAG,CAACkC,UAAU,CAAC;EACrEJ,IAAI,CAACc,UAAU,CAACnD,MAAM,EAAEM,KAAK,EAAE,IAAI,CAAC;EACpC,OAAOC,GAAG;AACd;AAJAN","names":["readInt16BE","array","offset","exports","readUint16BE","readInt16LE","readUint16LE","writeUint16BE","value","out","Uint8Array","writeUint16LE","readInt32BE","readUint32BE","readInt32LE","readUint32LE","writeUint32BE","writeUint32LE","readInt64BE","hi","lo","readUint64BE","readInt64LE","readUint64LE","writeUint64BE","writeUint64LE","readUintBE","bitLength","Error","length","result","mul","i","readUintLE","writeUintBE","int_1","div","writeUintLE","readFloat32BE","view","DataView","buffer","byteOffset","byteLength","getFloat32","readFloat32LE","readFloat64BE","getFloat64","readFloat64LE","writeFloat32BE","setFloat32","writeFloat32LE","writeFloat64BE","setFloat64","writeFloat64LE"],"sources":["C:\\Users\\paete\\Prototype\\nftmusicProtoCopy\\client\\node_modules\\@stablelib\\binary\\binary.ts"],"sourcesContent":["// Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\n\n/**\n * Package binary provides functions for encoding and decoding numbers in byte arrays.\n */\n\nimport { isSafeInteger } from \"@stablelib/int\";\n\n// TODO(dchest): add asserts for correct value ranges and array offsets.\n\n/**\n * Reads 2 bytes from array starting at offset as big-endian\n * signed 16-bit integer and returns it.\n */\nexport function readInt16BE(array: Uint8Array, offset = 0): number {\n    return (((array[offset + 0] << 8) | array[offset + 1]) << 16) >> 16;\n}\n\n/**\n * Reads 2 bytes from array starting at offset as big-endian\n * unsigned 16-bit integer and returns it.\n */\nexport function readUint16BE(array: Uint8Array, offset = 0): number {\n    return ((array[offset + 0] << 8) | array[offset + 1]) >>> 0;\n}\n\n/**\n * Reads 2 bytes from array starting at offset as little-endian\n * signed 16-bit integer and returns it.\n */\nexport function readInt16LE(array: Uint8Array, offset = 0): number {\n    return (((array[offset + 1] << 8) | array[offset]) << 16) >> 16;\n}\n\n/**\n * Reads 2 bytes from array starting at offset as little-endian\n * unsigned 16-bit integer and returns it.\n */\nexport function readUint16LE(array: Uint8Array, offset = 0): number {\n    return ((array[offset + 1] << 8) | array[offset]) >>> 0;\n}\n\n/**\n * Writes 2-byte big-endian representation of 16-bit unsigned\n * value to byte array starting at offset.\n *\n * If byte array is not given, creates a new 2-byte one.\n *\n * Returns the output byte array.\n */\nexport function writeUint16BE(value: number, out = new Uint8Array(2), offset = 0): Uint8Array {\n    out[offset + 0] = value >>> 8;\n    out[offset + 1] = value >>> 0;\n    return out;\n}\n\nexport const writeInt16BE = writeUint16BE;\n\n/**\n * Writes 2-byte little-endian representation of 16-bit unsigned\n * value to array starting at offset.\n *\n * If byte array is not given, creates a new 2-byte one.\n *\n * Returns the output byte array.\n */\nexport function writeUint16LE(value: number, out = new Uint8Array(2), offset = 0): Uint8Array {\n    out[offset + 0] = value >>> 0;\n    out[offset + 1] = value >>> 8;\n    return out;\n}\n\nexport const writeInt16LE = writeUint16LE;\n\n/**\n * Reads 4 bytes from array starting at offset as big-endian\n * signed 32-bit integer and returns it.\n */\nexport function readInt32BE(array: Uint8Array, offset = 0): number {\n    return (array[offset] << 24) |\n        (array[offset + 1] << 16) |\n        (array[offset + 2] << 8) |\n        array[offset + 3];\n}\n\n/**\n * Reads 4 bytes from array starting at offset as big-endian\n * unsigned 32-bit integer and returns it.\n */\nexport function readUint32BE(array: Uint8Array, offset = 0): number {\n    return ((array[offset] << 24) |\n        (array[offset + 1] << 16) |\n        (array[offset + 2] << 8) |\n        array[offset + 3]) >>> 0;\n}\n\n/**\n * Reads 4 bytes from array starting at offset as little-endian\n * signed 32-bit integer and returns it.\n */\nexport function readInt32LE(array: Uint8Array, offset = 0): number {\n    return (array[offset + 3] << 24) |\n        (array[offset + 2] << 16) |\n        (array[offset + 1] << 8) |\n        array[offset];\n}\n\n/**\n * Reads 4 bytes from array starting at offset as little-endian\n * unsigned 32-bit integer and returns it.\n */\nexport function readUint32LE(array: Uint8Array, offset = 0): number {\n    return ((array[offset + 3] << 24) |\n        (array[offset + 2] << 16) |\n        (array[offset + 1] << 8) |\n        array[offset]) >>> 0;\n}\n\n/**\n * Writes 4-byte big-endian representation of 32-bit unsigned\n * value to byte array starting at offset.\n *\n * If byte array is not given, creates a new 4-byte one.\n *\n * Returns the output byte array.\n */\nexport function writeUint32BE(value: number, out = new Uint8Array(4), offset = 0): Uint8Array {\n    out[offset + 0] = value >>> 24;\n    out[offset + 1] = value >>> 16;\n    out[offset + 2] = value >>> 8;\n    out[offset + 3] = value >>> 0;\n    return out;\n}\n\nexport const writeInt32BE = writeUint32BE;\n\n/**\n * Writes 4-byte little-endian representation of 32-bit unsigned\n * value to array starting at offset.\n *\n * If byte array is not given, creates a new 4-byte one.\n *\n * Returns the output byte array.\n */\nexport function writeUint32LE(value: number, out = new Uint8Array(4), offset = 0): Uint8Array {\n    out[offset + 0] = value >>> 0;\n    out[offset + 1] = value >>> 8;\n    out[offset + 2] = value >>> 16;\n    out[offset + 3] = value >>> 24;\n    return out;\n}\n\n\nexport const writeInt32LE = writeUint32LE;\n\n/**\n * Reads 8 bytes from array starting at offset as big-endian\n * signed 64-bit integer and returns it.\n *\n * IMPORTANT: due to JavaScript limitation, supports exact\n * numbers in range -9007199254740991 to 9007199254740991.\n * If the number stored in the byte array is outside this range,\n * the result is not exact.\n */\nexport function readInt64BE(array: Uint8Array, offset = 0): number {\n    const hi = readInt32BE(array, offset);\n    const lo = readInt32BE(array, offset + 4);\n    return hi * 0x100000000 + lo - ((lo>>31) * 0x100000000);\n}\n\n/**\n * Reads 8 bytes from array starting at offset as big-endian\n * unsigned 64-bit integer and returns it.\n *\n * IMPORTANT: due to JavaScript limitation, supports values up to 2^53-1.\n */\nexport function readUint64BE(array: Uint8Array, offset = 0): number {\n    const hi = readUint32BE(array, offset);\n    const lo = readUint32BE(array, offset + 4);\n    return hi * 0x100000000 + lo;\n}\n\n/**\n * Reads 8 bytes from array starting at offset as little-endian\n * signed 64-bit integer and returns it.\n *\n * IMPORTANT: due to JavaScript limitation, supports exact\n * numbers in range -9007199254740991 to 9007199254740991.\n * If the number stored in the byte array is outside this range,\n * the result is not exact.\n */\nexport function readInt64LE(array: Uint8Array, offset = 0): number {\n    const lo = readInt32LE(array, offset);\n    const hi = readInt32LE(array, offset + 4);\n    return hi * 0x100000000 + lo - ((lo>>31) * 0x100000000);\n}\n\n\n/**\n * Reads 8 bytes from array starting at offset as little-endian\n * unsigned 64-bit integer and returns it.\n *\n * IMPORTANT: due to JavaScript limitation, supports values up to 2^53-1.\n */\nexport function readUint64LE(array: Uint8Array, offset = 0): number {\n    const lo = readUint32LE(array, offset);\n    const hi = readUint32LE(array, offset + 4);\n    return hi * 0x100000000 + lo;\n}\n\n/**\n * Writes 8-byte big-endian representation of 64-bit unsigned\n * value to byte array starting at offset.\n *\n * Due to JavaScript limitation, supports values up to 2^53-1.\n *\n * If byte array is not given, creates a new 8-byte one.\n *\n * Returns the output byte array.\n */\nexport function writeUint64BE(value: number, out = new Uint8Array(8), offset = 0): Uint8Array {\n    writeUint32BE(value / 0x100000000 >>> 0, out, offset);\n    writeUint32BE(value >>> 0, out, offset + 4);\n    return out;\n}\n\nexport const writeInt64BE = writeUint64BE;\n\n/**\n * Writes 8-byte little-endian representation of 64-bit unsigned\n * value to byte array starting at offset.\n *\n * Due to JavaScript limitation, supports values up to 2^53-1.\n *\n * If byte array is not given, creates a new 8-byte one.\n *\n * Returns the output byte array.\n */\nexport function writeUint64LE(value: number, out = new Uint8Array(8), offset = 0): Uint8Array {\n    writeUint32LE(value >>> 0, out, offset);\n    writeUint32LE(value / 0x100000000 >>> 0, out, offset + 4);\n    return out;\n}\n\nexport const writeInt64LE = writeUint64LE;\n\n/**\n * Reads bytes from array starting at offset as big-endian\n * unsigned bitLen-bit integer and returns it.\n *\n * Supports bit lengths divisible by 8, up to 48.\n */\nexport function readUintBE(bitLength: number, array: Uint8Array, offset = 0): number {\n    // TODO(dchest): implement support for bitLengths non-divisible by 8\n    if (bitLength % 8 !== 0) {\n        throw new Error(\"readUintBE supports only bitLengths divisible by 8\");\n    }\n    if (bitLength / 8 > array.length - offset) {\n        throw new Error(\"readUintBE: array is too short for the given bitLength\");\n    }\n    let result = 0;\n    let mul = 1;\n    for (let i = bitLength / 8 + offset - 1; i >= offset; i--) {\n        result += array[i] * mul;\n        mul *= 256;\n    }\n    return result;\n}\n\n/**\n * Reads bytes from array starting at offset as little-endian\n * unsigned bitLen-bit integer and returns it.\n *\n * Supports bit lengths divisible by 8, up to 48.\n */\nexport function readUintLE(bitLength: number, array: Uint8Array, offset = 0): number {\n    // TODO(dchest): implement support for bitLengths non-divisible by 8\n    if (bitLength % 8 !== 0) {\n        throw new Error(\"readUintLE supports only bitLengths divisible by 8\");\n    }\n    if (bitLength / 8 > array.length - offset) {\n        throw new Error(\"readUintLE: array is too short for the given bitLength\");\n    }\n    let result = 0;\n    let mul = 1;\n    for (let i = offset; i < offset + bitLength / 8; i++) {\n        result += array[i] * mul;\n        mul *= 256;\n    }\n    return result;\n}\n\n/**\n * Writes a big-endian representation of bitLen-bit unsigned\n * value to array starting at offset.\n *\n * Supports bit lengths divisible by 8, up to 48.\n *\n * If byte array is not given, creates a new one.\n *\n * Returns the output byte array.\n */\nexport function writeUintBE(bitLength: number, value: number,\n    out = new Uint8Array(bitLength / 8), offset = 0): Uint8Array {\n    // TODO(dchest): implement support for bitLengths non-divisible by 8\n    if (bitLength % 8 !== 0) {\n        throw new Error(\"writeUintBE supports only bitLengths divisible by 8\");\n    }\n    if (!isSafeInteger(value)) {\n        throw new Error(\"writeUintBE value must be an integer\");\n    }\n    let div = 1;\n    for (let i = bitLength / 8 + offset - 1; i >= offset; i--) {\n        out[i] = (value / div) & 0xff;\n        div *= 256;\n    }\n    return out;\n}\n\n/**\n * Writes a little-endian representation of bitLen-bit unsigned\n * value to array starting at offset.\n *\n * Supports bit lengths divisible by 8, up to 48.\n *\n * If byte array is not given, creates a new one.\n *\n * Returns the output byte array.\n */\nexport function writeUintLE(bitLength: number, value: number,\n    out = new Uint8Array(bitLength / 8), offset = 0): Uint8Array {\n    // TODO(dchest): implement support for bitLengths non-divisible by 8\n    if (bitLength % 8 !== 0) {\n        throw new Error(\"writeUintLE supports only bitLengths divisible by 8\");\n    }\n    if (!isSafeInteger(value)) {\n        throw new Error(\"writeUintLE value must be an integer\");\n    }\n    let div = 1;\n    for (let i = offset; i < offset + bitLength / 8; i++) {\n        out[i] = (value / div) & 0xff;\n        div *= 256;\n    }\n    return out;\n}\n\n/**\n * Reads 4 bytes from array starting at offset as big-endian\n * 32-bit floating-point number and returns it.\n */\nexport function readFloat32BE(array: Uint8Array, offset = 0): number {\n    const view = new DataView(array.buffer, array.byteOffset, array.byteLength);\n    return view.getFloat32(offset);\n}\n\n/**\n * Reads 4 bytes from array starting at offset as little-endian\n * 32-bit floating-point number and returns it.\n */\nexport function readFloat32LE(array: Uint8Array, offset = 0): number {\n    const view = new DataView(array.buffer, array.byteOffset, array.byteLength);\n    return view.getFloat32(offset, true);\n}\n\n/**\n * Reads 8 bytes from array starting at offset as big-endian\n * 64-bit floating-point number (\"double\") and returns it.\n */\nexport function readFloat64BE(array: Uint8Array, offset = 0): number {\n    const view = new DataView(array.buffer, array.byteOffset, array.byteLength);\n    return view.getFloat64(offset);\n}\n\n/**\n * Reads 8 bytes from array starting at offset as little-endian\n * 64-bit floating-point number (\"double\") and returns it.\n */\nexport function readFloat64LE(array: Uint8Array, offset = 0): number {\n    const view = new DataView(array.buffer, array.byteOffset, array.byteLength);\n    return view.getFloat64(offset, true);\n}\n\n/**\n * Writes 4-byte big-endian floating-point representation of value\n * to byte array starting at offset.\n *\n * If byte array is not given, creates a new 4-byte one.\n *\n * Returns the output byte array.\n */\nexport function writeFloat32BE(value: number, out = new Uint8Array(4), offset = 0): Uint8Array {\n    const view = new DataView(out.buffer, out.byteOffset, out.byteLength);\n    view.setFloat32(offset, value);\n    return out;\n}\n\n/**\n * Writes 4-byte little-endian floating-point representation of value\n * to byte array starting at offset.\n *\n * If byte array is not given, creates a new 4-byte one.\n *\n * Returns the output byte array.\n */\nexport function writeFloat32LE(value: number, out = new Uint8Array(4), offset = 0): Uint8Array {\n    const view = new DataView(out.buffer, out.byteOffset, out.byteLength);\n    view.setFloat32(offset, value, true);\n    return out;\n}\n\n/**\n * Writes 8-byte big-endian floating-point representation of value\n * to byte array starting at offset.\n *\n * If byte array is not given, creates a new 8-byte one.\n *\n * Returns the output byte array.\n */\nexport function writeFloat64BE(value: number, out = new Uint8Array(8), offset = 0): Uint8Array {\n    const view = new DataView(out.buffer, out.byteOffset, out.byteLength);\n    view.setFloat64(offset, value);\n    return out;\n}\n\n/**\n * Writes 8-byte little-endian floating-point representation of value\n * to byte array starting at offset.\n *\n * If byte array is not given, creates a new 8-byte one.\n *\n * Returns the output byte array.\n */\nexport function writeFloat64LE(value: number, out = new Uint8Array(8), offset = 0): Uint8Array {\n    const view = new DataView(out.buffer, out.byteOffset, out.byteLength);\n    view.setFloat64(offset, value, true);\n    return out;\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}