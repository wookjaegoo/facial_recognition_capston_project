{"ast":null,"code":"'use strict';\n\nconst {\n  CID\n} = require('multiformats/cid');\nconst errCode = require('err-code');\n\n/**\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n */\n\n/**\n * Retrieves IPLD Nodes along the `path` that is rooted at `cid`.\n *\n * @param {CID} cid - the CID where the resolving starts\n * @param {string} path - the path that should be resolved\n * @param {import('ipfs-core-utils/src/multicodecs')} codecs\n * @param {(cid: CID, options?: AbortOptions) => Promise<Uint8Array>} getBlock\n * @param {AbortOptions} [options]\n */\nconst resolve = async function* (cid, path, codecs, getBlock, options) {\n  /**\n   * @param {CID} cid\n   */\n  const load = async cid => {\n    const codec = await codecs.getCodec(cid.code);\n    const block = await getBlock(cid, options);\n    return codec.decode(block);\n  };\n  const parts = path.split('/').filter(Boolean);\n  let value = await load(cid);\n  let lastCid = cid;\n  if (!parts.length) {\n    yield {\n      value,\n      remainderPath: ''\n    };\n  }\n\n  // End iteration if there isn't a CID to follow any more\n  while (parts.length) {\n    const key = parts.shift();\n    if (!key) {\n      throw errCode(new Error(`Could not resolve path \"${path}\"`), 'ERR_INVALID_PATH');\n    }\n    if (Object.prototype.hasOwnProperty.call(value, key)) {\n      value = value[key];\n      yield {\n        value,\n        remainderPath: parts.join('/')\n      };\n    } else {\n      throw errCode(new Error(`no link named \"${key}\" under ${lastCid}`), 'ERR_NO_LINK');\n    }\n    const cid = CID.asCID(value);\n    if (cid) {\n      lastCid = cid;\n      value = await load(value);\n    }\n  }\n};\nmodule.exports = resolve;","map":{"version":3,"names":["CID","require","errCode","resolve","cid","path","codecs","getBlock","options","load","codec","getCodec","code","block","decode","parts","split","filter","Boolean","value","lastCid","length","remainderPath","key","shift","Error","Object","prototype","hasOwnProperty","call","join","asCID","module","exports"],"sources":["C:/Users/paete/Prototype/nftmusicprotocopy/client/node_modules/ipfs-http-client/src/lib/resolve.js"],"sourcesContent":["'use strict'\n\nconst { CID } = require('multiformats/cid')\nconst errCode = require('err-code')\n\n/**\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n */\n\n/**\n * Retrieves IPLD Nodes along the `path` that is rooted at `cid`.\n *\n * @param {CID} cid - the CID where the resolving starts\n * @param {string} path - the path that should be resolved\n * @param {import('ipfs-core-utils/src/multicodecs')} codecs\n * @param {(cid: CID, options?: AbortOptions) => Promise<Uint8Array>} getBlock\n * @param {AbortOptions} [options]\n */\nconst resolve = async function * (cid, path, codecs, getBlock, options) {\n  /**\n   * @param {CID} cid\n   */\n  const load = async (cid) => {\n    const codec = await codecs.getCodec(cid.code)\n    const block = await getBlock(cid, options)\n\n    return codec.decode(block)\n  }\n\n  const parts = path.split('/').filter(Boolean)\n  let value = await load(cid)\n  let lastCid = cid\n\n  if (!parts.length) {\n    yield {\n      value,\n      remainderPath: ''\n    }\n  }\n\n  // End iteration if there isn't a CID to follow any more\n  while (parts.length) {\n    const key = parts.shift()\n\n    if (!key) {\n      throw errCode(new Error(`Could not resolve path \"${path}\"`), 'ERR_INVALID_PATH')\n    }\n\n    if (Object.prototype.hasOwnProperty.call(value, key)) {\n      value = value[key]\n\n      yield {\n        value,\n        remainderPath: parts.join('/')\n      }\n    } else {\n      throw errCode(new Error(`no link named \"${key}\" under ${lastCid}`), 'ERR_NO_LINK')\n    }\n\n    const cid = CID.asCID(value)\n\n    if (cid) {\n      lastCid = cid\n      value = await load(value)\n    }\n  }\n}\n\nmodule.exports = resolve\n"],"mappings":"AAAA,YAAY;;AAEZ,MAAM;EAAEA;AAAI,CAAC,GAAGC,OAAO,CAAC,kBAAkB,CAAC;AAC3C,MAAMC,OAAO,GAAGD,OAAO,CAAC,UAAU,CAAC;;AAEnC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAME,OAAO,GAAG,iBAAkBC,GAAG,EAAEC,IAAI,EAAEC,MAAM,EAAEC,QAAQ,EAAEC,OAAO,EAAE;EACtE;AACF;AACA;EACE,MAAMC,IAAI,GAAG,MAAOL,GAAG,IAAK;IAC1B,MAAMM,KAAK,GAAG,MAAMJ,MAAM,CAACK,QAAQ,CAACP,GAAG,CAACQ,IAAI,CAAC;IAC7C,MAAMC,KAAK,GAAG,MAAMN,QAAQ,CAACH,GAAG,EAAEI,OAAO,CAAC;IAE1C,OAAOE,KAAK,CAACI,MAAM,CAACD,KAAK,CAAC;EAC5B,CAAC;EAED,MAAME,KAAK,GAAGV,IAAI,CAACW,KAAK,CAAC,GAAG,CAAC,CAACC,MAAM,CAACC,OAAO,CAAC;EAC7C,IAAIC,KAAK,GAAG,MAAMV,IAAI,CAACL,GAAG,CAAC;EAC3B,IAAIgB,OAAO,GAAGhB,GAAG;EAEjB,IAAI,CAACW,KAAK,CAACM,MAAM,EAAE;IACjB,MAAM;MACJF,KAAK;MACLG,aAAa,EAAE;IACjB,CAAC;EACH;;EAEA;EACA,OAAOP,KAAK,CAACM,MAAM,EAAE;IACnB,MAAME,GAAG,GAAGR,KAAK,CAACS,KAAK,EAAE;IAEzB,IAAI,CAACD,GAAG,EAAE;MACR,MAAMrB,OAAO,CAAC,IAAIuB,KAAK,CAAE,2BAA0BpB,IAAK,GAAE,CAAC,EAAE,kBAAkB,CAAC;IAClF;IAEA,IAAIqB,MAAM,CAACC,SAAS,CAACC,cAAc,CAACC,IAAI,CAACV,KAAK,EAAEI,GAAG,CAAC,EAAE;MACpDJ,KAAK,GAAGA,KAAK,CAACI,GAAG,CAAC;MAElB,MAAM;QACJJ,KAAK;QACLG,aAAa,EAAEP,KAAK,CAACe,IAAI,CAAC,GAAG;MAC/B,CAAC;IACH,CAAC,MAAM;MACL,MAAM5B,OAAO,CAAC,IAAIuB,KAAK,CAAE,kBAAiBF,GAAI,WAAUH,OAAQ,EAAC,CAAC,EAAE,aAAa,CAAC;IACpF;IAEA,MAAMhB,GAAG,GAAGJ,GAAG,CAAC+B,KAAK,CAACZ,KAAK,CAAC;IAE5B,IAAIf,GAAG,EAAE;MACPgB,OAAO,GAAGhB,GAAG;MACbe,KAAK,GAAG,MAAMV,IAAI,CAACU,KAAK,CAAC;IAC3B;EACF;AACF,CAAC;AAEDa,MAAM,CAACC,OAAO,GAAG9B,OAAO"},"metadata":{},"sourceType":"script","externalDependencies":[]}